{"mappings":";;;;;;;;;;;;;AAAA;AAEA,MAAM,qCAAe,GAAiB;IACpC,IAAI,EAAE,SAAS;IACf,OAAO,EAAE,EAAE;IACX,QAAQ,EAAE,KAAK;CAChB;AAED,MAAM,6CAAuB,GAAG,CAC9B,YAAkC,GACjB;IACjB,OAAO;QAAE,GAAG,qCAAe;QAAE,GAAG,YAAY;KAAE,CAAA;CAC/C;AAED;;GAEG,CACH,MAAM,0CAAoB,GAAG,CAC3B,QAA6C,EAC7C,OAAiB,GACR;IACT,OAAO,CAAC,CAAC,KAAgB,GAAK;QAC5B,KAAK,CAAC,wBAAwB,GAAG,QAAQ;KAC1C,CAAC;CACH;AAED;;GAEG,CACH,MAAM,qCAAe,GAAG,CAAC,KAAyB,GAAK;IACrD,KAAK,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC,YAA0B,GAAK;QAChD,aAAa;QACb,KAAK,CAAC,wBAAwB,CAAC,YAAY,CAAC;KAC7C,CAAC;IACF,KAAK,CAAC,KAAK,EAAE;CACd;AAGM,MAAM,wCAAoB,GAAG,CAAA,GAAA,wBAAW,CAAA,CAAC,2BAA2B,EAAE;IAC3E,KAAK,EAAE,IAAiB;QACtB,OAAO;YACL,KAAK,EAAE,EAAE;YACT,wBAAwB,EAAE,SAAS;SACpC,CAAA;KACF;IAED,OAAO,EAAE;QACP;;;OAGG,CACH,GAAG,EAAC,KAAK,EAAkB;YACzB,OAAO,KAAK,CAAC,KAAK,CAAA;SACnB;KACF;IAED,OAAO,EAAE;QACP;;;OAGG,CACH,IAAI,EAAC,QAA6C,EAAE;YAClD,0CAAoB,CAAC,QAAQ,EAAE,IAAI,CAAC,MAAM,CAAC;YAE3C,IAAI,CAAC,UAAU,CAAC,IAAM;gBACpB,IAAI,IAAI,CAAC,KAAK,CAAC,MAAM,IAAI,CAAC,EAAE,OAAM;gBAElC,qCAAe,CAAC,IAAI,CAAC;aACtB,CAAC;YAEF,qCAAe,CAAC,IAAI,CAAC;SACtB;QAED;;OAEG,CACH,GAAG,EAAC,YAAkC,EAAE;YACtC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,6CAAuB,CAAC,YAAY,CAAC,CAAC;SACvD;QAED;;OAEG,CACH,GAAG,EAAC,aAAqC,EAAE;YACzC,IAAI,CAAC,KAAK,GAAG,aAAa,CAAC,GAAG,CAAC,CAAC,YAAY,GAAK;gBAC/C,OAAO,6CAAuB,CAAC,YAAY,CAAC,CAAA;aAC7C,CAAC;SACH;QAED;;OAEG,CACH,KAAK,IAAG;YACN,IAAI,CAAC,KAAK,GAAG,EAAE;SAChB;KACF;CACF,CAAC;IAEF,wCAAmC,GAApB,wCAAoB","sources":["src/index.ts"],"sourcesContent":["import { defineStore } from 'pinia'\n\nconst DEFAULT_MESSAGE: FlashMessage = {\n  type: 'success',\n  message: '',\n  position: 'top'\n}\n\nconst mergeWithDefaultMessage = (\n  flashMessage: FlashMessageArgument\n): FlashMessage => {\n  return { ...DEFAULT_MESSAGE, ...flashMessage }\n}\n\n/**\n * set callback function\n */\nconst showFlashMessageWith = (\n  callback: (flashMessage: FlashMessage) => any,\n  patcher: Function\n): void => {\n  patcher((state: RootState) => {\n    state.showFlashMessageFunction = callback\n  })\n}\n\n/**\n * display messages in View, with function that provided from vue component.\n */\nconst showAllMessages = (store: IFlashMessageStore) => {\n  store.all.forEach((flashMessage: FlashMessage) => {\n    // @ts-ignore\n    store.showFlashMessageFunction(flashMessage)\n  })\n  store.clear()\n}\n\n// store definition\nexport const useFlashMessageStore = defineStore('[odd] flash-message-store', {\n  state: (): RootState => {\n    return {\n      queue: [],\n      showFlashMessageFunction: undefined\n    }\n  },\n\n  getters: {\n    /**\n     * list all flash messages in an array\n     * @returns {FlashMessage[]}\n     */\n    all(state): FlashMessage[] {\n      return state.queue\n    }\n  },\n\n  actions: {\n    /**\n     * initializing flash message store. if any change happen to `queue` and include new messages, `showAllMessages`\n     * will been called for display messages in View.\n     */\n    init(callback: (flashMessage: FlashMessage) => any) {\n      showFlashMessageWith(callback, this.$patch)\n\n      this.$subscribe(() => {\n        if (this.queue.length <= 0) return\n\n        showAllMessages(this)\n      })\n\n      showAllMessages(this)\n    },\n\n    /**\n     * add a message into flash message queue\n     */\n    add(flashMessage: FlashMessageArgument) {\n      this.queue.push(mergeWithDefaultMessage(flashMessage))\n    },\n\n    /**\n     * assign flash message array into queue directly.\n     */\n    set(flashMessages: FlashMessageArgument[]) {\n      this.queue = flashMessages.map((flashMessage) => {\n        return mergeWithDefaultMessage(flashMessage)\n      })\n    },\n\n    /**\n     * remove all messages\n     */\n    clear() {\n      this.queue = []\n    }\n  }\n})\n\nexport default useFlashMessageStore\n"],"names":[],"version":3,"file":"index.js.map"}